/* 
    在let 出现之前，for循环定义的迭代变量会渗透到循环体外部:
*/
for (var i = 0; i < 5; ++i) {
    // 循环逻辑
}
console.log(i); //5

/* 改成使用let之后，这个问题就消失了，因为迭代变量的作用域仅限于for循环块内部： */

for (let i = 0; i < 5; i++) {
    // 循环逻辑
}
console.log(i); // i 没有定义

/* 在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改： */

for (var i = 0; i < 5; ++i) {
    setTimeout(() => console.log(i), 0)
}
// 实际上会输出5,5,5,5,5
/* 之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5 在之后执行超时逻辑时，所有的i都是同一个变量，因而输出的都是同一个最终值 */
/* 而在使用let声明迭代变量时，JavaScript引用的都是不同的变量实例，所以console.log输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值 */
for (let i = 0; i < 5; ++i) {
    setTimeout(() => console.log(i), 0)
}
// 会输出0,1,2,3,4
/* 这种每次迭代声明一个独立变量实例的行为适用于所有风格的for循环，包括for-in和for-of循环 */